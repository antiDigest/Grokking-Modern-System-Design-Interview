# Evaluation of a Distributed Search's Design

## Availability
We utilized distributed storage to store these items:

- Documents crawled by the indexer.
- Inverted indexes generated by the indexing nodes.

Data is replicated across multiple regions in distributed storage, making cross-region deployment for indexing and search easier. The group of indexing and search nodes merely needs to be replicated in different availability zones. Therefore, we deploy the cluster of indexing and search nodes in different availability zones. So, if a failure occurs in one place, we can process the requests from another cluster. Multiple groups of indexing and search nodes help to achieve high indexing and search availability. Moreover, in each cluster, if a node dies, another can take its place.

The indexing is performed offline, not on the user’s critical path. We don’t need to replicate the indexing operations synchronously. It is unnecessary to respond to the user search queries with the latest data that has just been added to the index. So, we don’t have to wait for the replication of the new index to respond to the search queries. This makes the search available to the users.

```
Note: Once we replicate the latest data in all groups of indexing nodes and the search nodes have downloaded it, then the search queries are performed on the latest data.
```

![Guarantees provided by the distributed search](./evaluation.jpg)


## Scalability
Partitioning is an essential component of search systems to scale. When we increase the number of partitions and add more nodes to the indexing and search clusters, we can scale in terms of data indexing and querying.

The strong isolation of indexing and search processes help indexing and search scale independently and dynamically.

## Fast search on big data
We utilized a number of nodes, each of which performs search queries in parallel on smaller inverted indices. The result from each search node is then merged and returned to the user.

## Reduced cost
We used cheaper machines to compute indexes and perform searches. If one node fails, we don’t have to recompute the complete index. Instead, some of the documents need to be indexed again.

## Conclusion
A search system is required for almost every application. We have seen that it isn’t possible to develop a search system that can run on a single node. We utilized a parallel computation framework and low-cost machines to build a search system that is available, scalable, and highly performant.



## How will we design a distributed search system?
We divided the design of a distributed search system into five lessons:

1. [Requirements](../Requirements%20of%20a%20Distributed%20Search%20System's%20Design/): In this lesson, we list the functional and non-functional requirements of a distributed search system. We also estimate our system’s resources, such as servers, storage, and the bandwidth needed to serve a number of queries.
2. [Indexing](../Indexing%20in%20a%20Distributed%20Search/): This lesson provides us with background knowledge on the process of indexing with the help of an example. After discussing indexing, we also look into a centralized architecture of distributed search systems.
3. [Initial design](../Design%20of%20a%20Distributed%20Search/): This lesson consists of the high-level design of our system, its API, and the details of the indexing and searching process.
4. [Final design](../Scaling%20Search%20and%20Indexing/): In this lesson, we evaluate our previous design and revamp it to make it more scalable.
5. [Evaluation](../Evaluation%20of%20a%20Distributed%20Search's%20Design/): This lesson explains how our designed distributed search system fulfills its requirements.
Let’s start by understanding the requirements of designing a distributed search system.


## Move on to [Distributed Logging](../../Distributed%20Logging/System%20Design%20Distributed%20Logging/)